<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Async/Await in JavaScript</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
            background-color: #f9f9f9;
        }
        h1, h2 {
            color: #333;
        }
        code {
            background-color: #eef;
            padding: 2px 4px;
            border-radius: 4px;
        }
        pre {
            background-color: #eef;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
    </style>
</head>
<body>

<h1>Async/Await in JavaScript</h1>
<p><strong>Async/await</strong> is a modern way to handle asynchronous operations in JavaScript. It allows you to write asynchronous code in a more synchronous fashion, making it easier to read and understand. Async functions always return a Promise, and the <code>await</code> keyword can be used to pause the execution of the async function until the Promise is resolved.</p>

<h2>Understanding Async Functions</h2>
<p>An <code>async</code> function is a function that is declared with the <code>async</code> keyword. This indicates that the function will contain asynchronous code that returns a Promise.</p>

<h3>Example 1: Basic Async Function</h3>
<pre><code>async function myAsyncFunction() {
    return "Hello, Async!";
}</code></pre>
<p><strong>Explanation:</strong> This function, <code>myAsyncFunction</code>, is an async function that will implicitly return a Promise. When called, it resolves with the string "Hello, Async!".</p>

<h2>Using Await</h2>
<p>The <code>await</code> keyword is used to wait for a Promise to resolve or reject. It can only be used inside an async function.</p>

<h3>Example 2: Using Await with Promises</h3>
<pre><code>async function fetchData() {
    const promise = new Promise((resolve) =&gt; {
        setTimeout(() =&gt; resolve("Data fetched!"), 2000);
    });

    const result = await promise;
    console.log(result); // Outputs: Data fetched!
}</code></pre>
<p><strong>Explanation:</strong> In this example, <code>fetchData</code> is an async function that creates a Promise that resolves after 2 seconds. The <code>await</code> keyword pauses the execution of <code>fetchData</code> until the Promise resolves, then logs the result.</p>

<h2>Error Handling with Try/Catch</h2>
<p>You can use a <code>try/catch</code> block to handle errors when using async/await.</p>

<h3>Example 3: Error Handling</h3>
<pre><code>async function fetchWithError() {
    const promise = new Promise((_, reject) =&gt; {
        setTimeout(() =&gt; reject("Error fetching data!"), 2000);
    });

    try {
        const result = await promise;
        console.log(result);
    } catch (error) {
        console.log(error); // Outputs: Error fetching data!
    }
}</code></pre>
<p><strong>Explanation:</strong> In this example, <code>fetchWithError</code> simulates an error when fetching data. The <code>try/catch</code> block allows us to catch the error when the Promise is rejected and log the error message.</p>

<h2>Combining Async/Await with Other Functions</h2>
<p>You can combine async/await with regular functions to improve code readability and maintainability.</p>

<h3>Example 4: Combining Functions</h3>
<pre><code>function simulateFetch() {
    return new Promise((resolve) =&gt; {
        setTimeout(() =&gt; resolve("Fetched Data!"), 1500);
    });
}

async function fetchAndLog() {
    const data = await simulateFetch();
    console.log(data); // Outputs: Fetched Data!
}</code></pre>
<p><strong>Explanation:</strong> Here, <code>simulateFetch</code> is a regular function that returns a Promise. The async function <code>fetchAndLog</code> uses <code>await</code> to get the fetched data and log it to the console.</p>

<h2>Async/Await with Promise.all()</h2>
<p>You can use async/await with <code>Promise.all()</code> to handle multiple asynchronous operations concurrently.</p>

<h3>Example 5: Using Promise.all() with Async/Await</h3>
<pre><code>async function fetchMultipleData() {
    const promise1 = new Promise((resolve) =&gt; setTimeout(() =&gt; resolve("Data 1"), 1000));
    const promise2 = new Promise((resolve) =&gt; setTimeout(() =&gt; resolve("Data 2"), 2000));
    const promise3 = new Promise((resolve) =&gt; setTimeout(() =&gt; resolve("Data 3"), 1500));

    const results = await Promise.all([promise1, promise2, promise3]);
    console.log(results); // Outputs: ["Data 1", "Data 2", "Data 3"]
}</code></pre>
<p><strong>Explanation:</strong> In this example, <code>fetchMultipleData</code> uses <code>Promise.all()</code> to wait for multiple Promises to resolve. The results are logged once all Promises have resolved.</p>

<h2>Returning Values from Async Functions</h2>
<p>Async functions can return values just like regular functions, but they will always return a Promise.</p>

<h3>Example 6: Returning Values</h3>
<pre><code>async function getValue() {
    return "Returned Value!";
}

getValue().then(value =&gt; {
    console.log(value); // Outputs: Returned Value!
});</code></pre>
<p><strong>Explanation:</strong> The async function <code>getValue</code> returns a string. When called, it returns a Promise that resolves with that string, which can then be accessed using <code>then()</code>.</p>

<h2>Conclusion</h2>
<p>Async/await simplifies working with asynchronous code in JavaScript. By allowing you to write code that looks synchronous, it improves readability and makes error handling easier. Understanding async/await is essential for modern JavaScript development, especially when dealing with asynchronous operations like API calls and data fetching.</p>

</body>
</html>
