<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Abstraction in Python</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f9f9f9;
        }
        h1, h2, h3 {
            color: #333;
        }
        p {
            font-size: 16px;
            line-height: 1.6;
        }
        .example-code {
            background-color: #f4f4f4;
            border-left: 4px solid #007bff;
            padding: 10px;
            margin: 15px 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        ul {
            list-style-type: square;
            margin-left: 20px;
        }
    </style>
</head>
<body>

    <h1>Understanding Abstraction in Python</h1>
    <p><strong>Abstraction</strong> is one of the four fundamental concepts of Object-Oriented Programming (OOP), alongside encapsulation, inheritance, and polymorphism. In simple terms, abstraction is the concept of hiding the complex implementation details and only exposing the essential parts of an object or a function. It allows us to focus on what an object does rather than how it does it.</p>
    
    <p>By using abstraction, we can define a generic blueprint (abstract class) for a set of actions that different objects can perform, while the implementation of those actions is left to the child classes.</p>

    <h2>Key Concepts of Abstraction in Python</h2>
    <ul>
        <li><strong>Abstract Classes:</strong> A class that cannot be instantiated directly. It serves as a blueprint for other classes.</li>
        <li><strong>Abstract Methods:</strong> Methods declared in an abstract class that must be implemented by any subclass inheriting from it.</li>
        <li><strong>Hiding Details:</strong> Only the relevant functionality is exposed, while complex details are hidden from the user.</li>
    </ul>

    <h2>Why Use Abstraction?</h2>
    <p>Abstraction helps in managing the complexity of large systems by breaking down the system into more manageable parts. It also promotes the use of reusable and modular code. For example, when you use a car, you don’t need to understand how the engine works; you only need to know how to drive it. This is abstraction in real life.</p>

    <h2>Abstraction in Python</h2>
    <p>Python supports abstraction using abstract classes and methods. Python’s <code>abc</code> module provides tools to define abstract base classes. An abstract base class (ABC) can contain one or more abstract methods, which are methods that are declared but contain no implementation.</p>

    <h3>Example of an Abstract Class and Abstract Method</h3>
    <p>In the example below, we define an abstract class <code>Shape</code> with an abstract method <code>area()</code>. Any class that inherits from <code>Shape</code> must implement the <code>area()</code> method:</p>

    <div class="example-code">
        <code>
        from abc import ABC, abstractmethod

        # Define the abstract class
        class Shape(ABC):
            @abstractmethod
            def area(self):
                pass  # Abstract method (no implementation)

        # Subclass that implements the abstract method
        class Circle(Shape):
            def __init__(self, radius):
                self.radius = radius

            def area(self):
                return 3.14 * (self.radius ** 2)

        # Subclass that implements the abstract method
        class Rectangle(Shape):
            def __init__(self, length, width):
                self.length = length
                self.width = width

            def area(self):
                return self.length * self.width

        # Create objects of the subclasses
        circle = Circle(5)
        rectangle = Rectangle(4, 6)

        print("Area of Circle:", circle.area())  # Output: Area of Circle: 78.5
        print("Area of Rectangle:", rectangle.area())  # Output: Area of Rectangle: 24
        </code>
    </div>

    <h3>Explanation:</h3>
    <ul>
        <li><strong>Abstract Class (Shape):</strong> The class <code>Shape</code> is abstract because it contains an abstract method <code>area()</code>. It cannot be instantiated directly.</li>
        <li><strong>Abstract Method (area):</strong> The <code>area()</code> method in the <code>Shape</code> class is defined as abstract using the <code>@abstractmethod</code> decorator. Any class inheriting from <code>Shape</code> must implement this method.</li>
        <li><strong>Subclasses:</strong> The <code>Circle</code> and <code>Rectangle</code> classes inherit from <code>Shape</code> and provide their own implementations of the <code>area()</code> method.</li>
    </ul>

    <h2>How to Use Abstraction in Python</h2>
    <p>In Python, abstraction is typically used in cases where you want to define a general blueprint for a group of related objects. For instance, if you are building an application that deals with multiple shapes (circle, rectangle, square), you might create an abstract class for a general shape, while the specific details are handled by each individual shape class.</p>

    <h3>Another Example: Payment System</h3>
    <p>Let’s take the example of a payment system. We can define an abstract class <code>Payment</code> that outlines the basic structure for any type of payment (credit card, debit card, PayPal). The specific implementation of how each payment method works will be defined by the subclasses.</p>

    <div class="example-code">
        <code>
        from abc import ABC, abstractmethod

        class Payment(ABC):
            @abstractmethod
            def pay(self, amount):
                pass  # Abstract method

        class CreditCardPayment(Payment):
            def pay(self, amount):
                print(f"Processing credit card payment of {amount} dollars.")

        class PayPalPayment(Payment):
            def pay(self, amount):
                print(f"Processing PayPal payment of {amount} dollars.")

        # Create instances of the payment types
        credit_payment = CreditCardPayment()
        paypal_payment = PayPalPayment()

        # Make payments
        credit_payment.pay(100)  # Output: Processing credit card payment of 100 dollars.
        paypal_payment.pay(200)  # Output: Processing PayPal payment of 200 dollars.
        </code>
    </div>

    <h3>Explanation:</h3>
    <ul>
        <li>The abstract class <code>Payment</code> defines an abstract method <code>pay()</code>.</li>
        <li>The <code>CreditCardPayment</code> and <code>PayPalPayment</code> classes inherit from <code>Payment</code> and provide their own implementations of the <code>pay()</code> method.</li>
        <li>We create objects of <code>CreditCardPayment</code> and <code>PayPalPayment</code> and call the <code>pay()</code> method on them to process payments.</li>
    </ul>

    <h2>Advantages of Abstraction</h2>
    <ul>
        <li><strong>Code Reusability:</strong> Abstract classes allow you to define a common interface for different types of objects, promoting code reuse.</li>
        <li><strong>Modularity:</strong> It helps in dividing complex systems into smaller, manageable parts, making the code modular and easy to maintain.</li>
        <li><strong>Maintainability:</strong> By focusing on what an object should do rather than how it does it, abstraction helps improve the maintainability of code.</li>
    </ul>

    <h2>Conclusion</h2>
    <p>Abstraction is a powerful concept in Python's Object-Oriented Programming, allowing developers to design more modular and reusable code. By defining abstract classes and methods, you can create a structured blueprint for different objects while leaving the specific details to the subclasses. It hides unnecessary complexity from the end user and helps keep code clean and easy to maintain.</p>

</body>
</html>
